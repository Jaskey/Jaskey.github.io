<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: String | 力学笃行的猪]]></title>
  <link href="http://jaskey.github.io/blog/categories/string/atom.xml" rel="self"/>
  <link href="http://jaskey.github.io/"/>
  <updated>2014-12-16T11:34:13+08:00</updated>
  <id>http://jaskey.github.io/</id>
  <author>
    <name><![CDATA[Jaskey Lam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[+ 操作符vs StringBuilder.append]]></title>
    <link href="http://jaskey.github.io/blog/2014/12/16/plus-vs-stringbuilder/"/>
    <updated>2014-12-16T11:10:13+08:00</updated>
    <id>http://jaskey.github.io/blog/2014/12/16/plus-vs-stringbuilder</id>
    <content type="html"><![CDATA[<p>关于String, StringBuilder/StringBuffer 这些本来都是老生长谈的话题了。但今天仍然想要总结下到底这些有什么区别，具体什么场合适合适用哪种。</p>

<p>关于<code>StringBuilder</code>和 <code>StringBuffer</code>就一个线程不安全，一个线程安全，今天暂且不讨论。</p>

<h1><code>+</code>操作符背后发生了什么</h1>

<p>所有的<code>+</code>操作符，其实都会被编译器改写。但有以下两种情况:</p>

<ul>
<li><p><strong>String的链接(+)，将被编译器改写成StringBuilder的连接。</strong></p></li>
<li><p><strong>String literal（字符串值）的连接(+)，将被编译器改写成新的字符串常量值(String literal)。</strong></p></li>
</ul>


<p>以下举例说明：</p>

<pre><code>public void method1() {
    System.out.println("hello  " + "world");
}

public void method2(String name) {
    System.out.println("hello " + name);
}

public void method3(name) {
    String a = "hello " + name;
    System.out.println(a + " I am a programmer");
}
</code></pre>

<p> 实际上会被编译器改写成：</p>

<pre><code>public void method1()
{
    System.out.println("hello world");//被直接改写成新的字符串值
}

public void method2(String name)
{
    System.out.println((new StringBuilder("hello ")).append(name).toString());//使用StringBuilder改写
}

public void method3(String name)
{
    String a = (new StringBuilder("hello ")).append(name).toString();//使用StringBuilder改写
    System.out.println((new StringBuilder(String.valueOf(a))).append(" I am a programmer").toString());//又创建了一个StringBuilder对象改写
}
</code></pre>

<ul>
<li><code>method1</code>，String字符串值（String literal）的连接，编译器已经在编译时就改写成了一个新的字符串值。</li>
<li><code>method2</code>, String的连接会被改写成使用StringBuilder</li>
<li><code>method3</code>,由于有两次的连接，编译器帮我们新建了第二个StringBuilder的实例而不是重用之前的</li>
</ul>


<h1>如何选择</h1>

<p>由上可知，所有字符串的连接实际上要不就在编译被改写成新的字符串值，要不就是改用<code>StringBuilder</code>去做连接操作。所以，对于简单的操作，<code>String</code>的<code>+</code>操作，实际上性能不会低于StringBuilder，甚至会高于（在字符串本身是常量值的连接时）。所以所有的简单单句话字符串连接，都应该直接使用<code>+</code>，这性能并不会低反而可能更加高，而且更具有可读性。</p>

<p>这明显和我们常听说的不一致，主要原因在于像以上的<code>method3</code>,由于每一句单独的<code>+</code>操作语句，都会新建立一个StringBuilder对象去处理连接操作。这当然是性能很差的，我们更加希望就重用一个对象，在改对象不断的新增加值。典型的例子如在循环中构建字符串对象：</p>

<pre><code>String result = "";
for (String s : hugeArray) {
    result = result + s;//每次的连接都会新创建一个StringBuilder对象去处理，将重复创建非常多的StringBuilder对象
}
</code></pre>

<p>我们就应该手动的重用一个StringBuilder对象去处理：</p>

<pre><code>StringBuilder sb = new StringBuilder();
for (String s : hugeArray) {
    sb.append(s);//重用一个StringBuilder对象，直接处理新增字符串值的操作
}
String result = sb.toString();
</code></pre>
]]></content>
  </entry>
  
</feed>
